\section{Estructuras y uniones en C. Campos de bit.}
\setcounter{subsection}{9}

\subsection*{Estructuras}
\subsubsection{Ejercicio 1}
Crear las estructuras según los siguientes requerimientos:
\begin{itemize}
  \item Una estructura \texttt{inventario} que contenga un arreglo de 30 char llamado \texttt{nombre}, un entero \texttt{numero\_parte}, flotante \texttt{precio}, y un entero \texttt{stock}
  \item  Una estrucura que contenga los siguientes arreglos: un arreglo de 20 elementos para el nombre de la calle \texttt{direccion}, un arreglo \texttt{ciudad} de 25 elementos para el nombre de la ciudad, un arreglo \texttt{codpost} de 6 elementos para el código postal.
\end{itemize}
Dentro de \texttt{main} se tienen inicializar las estructuras anteriores.

\subsubsection{Ejercicio 2} 
Dada la siguiente estructura:
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/estructura.c}
Escribir un programa que cumpla con:
\begin{enumerate}[a)]
  \item Solicitar al usuario ingresar cada dato de la estructura y almacenarlo.
  \item Imprimir los datos cargados por el usuario.
\end{enumerate}

\subsubsection{Ejercicio 3} 
 Completar el siguiente programa para ingresar los miembros de cada elemento de tipo \texttt{alumno} en el arreglo \texttt{alumnos}.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/ejercicio3_estructuras.c}
El programa debe cumplir:
\begin{itemize}
  \item Se debe validar que el legajo y DNI sea un número positivo
  \item El usuario debe cargar las 3 notas. Luego con esta información, el programa calcula y almacena el promedio de cada alumno en el miembro \texttt{promedio}.
  \item El programa debe determinar el \texttt{estado} académico del alumno según:
    \begin{itemize}
      \item Promoción: promedio mayor o igual a 8.
      \item Regular: promedio maoyor o igual a 6 y menor que 8.
      \item Libre: promedio menor a 6.
    \end{itemize}
\end{itemize}

\subsection*{Uniones y Enumeraciones}

\subsubsection{Ejercicio 1} 
En los siguientes fragmentos de programa, determinar si son correctos o no. En caso de no serlo justificar.
\begin{enumerate}[a)]
  \item \_
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo0.c}
  \item \_
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo1.c}
  \item Suponga que estructura \texttt{carta} se ha definido con dos punteros para char (número y palo).
  %\lstset{inputencoding=utf8/latin1}
  %\lstinputlisting[style=customc]{teo3.c}
    Además, la variable c se ha definido para ser de tipo struct carta y la variable cPtr se ha definido para ser de tipo puntero a struct carta. 
    A la variable cPtr se le ha asignado la dirección de c.
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo4.c}
\end{enumerate}
\subsubsection{Ejercicio 2} 
Indique si cada uno de los siguientes es verdadero o falso. Si es falso, explique por qué.
\begin{enumerate}[a)]
  \item Las estructuras pueden contener variables de un solo tipo de datos.
  \item Se pueden comparar dos uniones (usando ==) para determinar si son iguales.
  \item El nombre de la etiqueta de una estructura es opcional.
  \item Los miembros de diferentes estructuras deben tener nombres únicos.
  \item La palabra clave typedef se usa para definir nuevos tipos de datos.
  \item Las estructuras siempre se pasan a las funciones por referencia.
  \item Las estructuras no pueden compararse utilizando operadores == y! =.
\end{enumerate}

\subsubsection{Ejercicio 3} 
Escriba el código para lograr cada uno de los siguientes:
\begin{enumerate}[a)]
  \item Defina una estructura llamada parte que contenga la variable int sin signo partNumber y char array partName con valores que pueden tener hasta 25 caracteres (incluido el carácter nulo de terminación).
  \item Definir Parte como sinónimo de la parte de tipo estructura.
  \item Use Part para declarar que la variable a sea de tipo struct part, la matriz b [10] sea de tipo struct parte y la variable ptr para que sea de tipo puntero a struct part.
  \item Lea un número de parte y un nombre de parte del teclado en los miembros individuales de la variable a.
  \item Asigne los valores de miembro de la variable a al elemento 3 de la matriz b.
  \item Asigne la dirección de la matriz b a la variable de puntero ptr.
  \item Imprima los valores de miembros del elemento 3 de la matriz b usando la variable ptr y el operador de puntero de estructura para referirse a los miembros.
\end{enumerate}
\subsubsection{Ejercicio 4} 
Dada la estructura  \texttt{personaje\_t}, realizar un programa que solicite al usuario ingresar los datos necesarios para completar la estructura.
Los miembros \texttt{escudo} y \texttt{sales} deben ser inicializados en 0. 
El miembro \texttt{vida} en $150.0$.
El miembro \texttt{rango} se debe generar en forma aleatoria, con un valor entre $0$ y $100$.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/personaje.c}
El programa debe cargar los miembros mediante dos formas: la primera en forma directa con la variable \texttt{personaje}, y en forma indirecta mediante el puntero \texttt{pPersonaje} según la siguiente definición:

\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/sol_personaje_ej.c}
Acontinuación se adjunta un ejemplo de salida válido:
\lstset{inputencoding=utf8/latin1}
{\small
\lstinputlisting[backgroundcolor = \color{lightgray}]{code/sol_personaje_salida.mn}
}

\subsection*{Campos de bits}
\subsubsection*{Ejercicio 1} 
Dado el siguiente programa, implementar las funciones según las especificaciones indicadas en los comentarios.
El mazo de cartas debe ser inicializado de manera aleatoria, estando permitida la repetición de cartas.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/ejercicio1_campo.c}
A continuación se muestra un ejemplo de salida del programa:
\lstset{inputencoding=utf8/latin1}
{\small
\lstinputlisting[backgroundcolor = \color{lightgray}]{code/ejercicio1_campo_completo_salida.mn}
}


