\section{RA9}
\subsection*{Resultados de aprendizaje}
Crear y utilizar estructuras, uniones, enumeraciones y campos de bit para formar en conjunción con los punteros estructuras dinámicas de datos, reducir los requerimientos de memoria de un programa, lograr que sean más auto documentables los mismos y hacer uso del hardware a bajo nivel teniendo en cuenta que estas características son valiosas para los programadores que escriben software de sistemas, como por ejemplo sistemas operativos, device drivers, software de redes, etc.

\subsection*{Contenido según programa}
Unidad 9. Estructuras y uniones en C. Campos de bit.  Estructuras de datos. Bases de las Estructuras. Sintaxis: Definición de estructura.  Acceso a los miembros de una estructura. Punteros a estructuras. Arreglos de estructuras. Funciones y Estructuras. Estructuras autoreferenciadas. Typedef.  Uniones. Definición. Acceso a los miembros de una unión. Campos de bit.  Definición. Acceso a los miembros de un campo de bits. Constantes de Enumeración. Aplicaciones relacionadas.

Unidad 10. Uso del lenguaje C en aplicaciones de bajo nivel.  Operadores a nivel de bit.  Operadores lógicos.  Operadores de desplazamiento.  Aplicaciones relacionadas.  E/S mapeada en memoria.  Puertos GPIO. Modelo de programación de un puerto.  Controlador de dispositivo (device driver). Interfaces de programación APIs.

Unidad 11. Manejo de archivos en C.  Concepto de Flujo de datos (streams). Creación, apertura y cierre de archivos de texto. Archivos binarios.  Funciones para lectura y escritura de bajo nivel.  Acceso secuencial vs.  acceso directo. Uso de las funciones de archivos para acceder a dispositivos de E/S. Concepto ``todo es un archivo''. Ejemplos.

\setcounter{subsection}{9}

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\subsection*{Estructuras}

\subsubsection{Ejercicio}
Crear las estructuras según los siguientes requerimientos:
\begin{itemize}
  \item Una estructura \texttt{inventario} que contenga un arreglo de 30 char llamado \texttt{nombre}, un entero \texttt{numero\_parte}, flotante \texttt{precio}, y un entero \texttt{stock}
  \item  Una estrucura que contenga los siguientes arreglos: un arreglo de 20 elementos para el nombre de la calle \texttt{direccion}, un arreglo \texttt{ciudad} de 25 elementos para el nombre de la ciudad, un arreglo \texttt{codpost} de 6 elementos para el código postal.
\end{itemize}
Dentro de \texttt{main} se tienen inicializar las estructuras anteriores.

\subsubsection{Ejercicio}
Dada la siguiente estructura:
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/estructura.c}
Escribir un programa que cumpla con:
\begin{enumerate}[a)]
  \item Solicitar al usuario ingresar cada dato de la estructura y almacenarlo.
  \item Imprimir los datos cargados por el usuario.
\end{enumerate}

\subsubsection{Ejercicio}
 Completar el siguiente programa para ingresar los miembros de cada elemento de tipo \texttt{alumno} en el arreglo \texttt{alumnos}.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/ejercicio3_estructuras.c}
El programa debe cumplir:
\begin{itemize}
  \item Se debe validar que el legajo y DNI sea un número positivo
  \item El usuario debe cargar las 3 notas. Luego con esta información, el programa calcula y almacena el promedio de cada alumno en el miembro \texttt{promedio}.
  \item El programa debe determinar el \texttt{estado} académico del alumno según:
    \begin{itemize}
      \item Promoción: promedio mayor o igual a 8.
      \item Regular: promedio maoyor o igual a 6 y menor que 8.
      \item Libre: promedio menor a 6.
    \end{itemize}
\end{itemize}

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\subsection*{Uniones y Enumeraciones}

\subsubsection{Ejercicio}
En los siguientes fragmentos de programa, determinar si son correctos o no. En caso de no serlo justificar.
\begin{enumerate}[a)]
  \item \_
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo0.c}
  \item \_
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo1.c}
  \item Suponga que estructura \texttt{carta} se ha definido con dos punteros para char (número y palo).
  %\lstset{inputencoding=utf8/latin1}
  %\lstinputlisting[style=customc]{teo3.c}
    Además, la variable c se ha definido para ser de tipo struct carta y la variable cPtr se ha definido para ser de tipo puntero a struct carta. 
    A la variable cPtr se le ha asignado la dirección de c.
  \lstset{inputencoding=utf8/latin1}
  \lstinputlisting[style=customc]{code/teo4.c}
\end{enumerate}
\subsubsection{Ejercicio}
Indique si cada uno de los siguientes es verdadero o falso. Si es falso, explique por qué.
\begin{enumerate}[a)]
  \item Las estructuras pueden contener variables de un solo tipo de datos.
  \item Se pueden comparar dos uniones (usando ==) para determinar si son iguales.
  \item El nombre de la etiqueta de una estructura es opcional.
  \item Los miembros de diferentes estructuras deben tener nombres únicos.
  \item La palabra clave typedef se usa para definir nuevos tipos de datos.
  \item Las estructuras siempre se pasan a las funciones por referencia.
  \item Las estructuras no pueden compararse utilizando operadores == y! =.
\end{enumerate}

\subsubsection{Ejercicio}
Escriba el código para lograr cada uno de los siguientes:
\begin{enumerate}[a)]
  \item Defina una estructura llamada parte que contenga la variable int sin signo partNumber y char array partName con valores que pueden tener hasta 25 caracteres (incluido el carácter nulo de terminación).
  \item Definir Parte como sinónimo de la parte de tipo estructura.
  \item Use Part para declarar que la variable a sea de tipo struct part, la matriz b [10] sea de tipo struct parte y la variable ptr para que sea de tipo puntero a struct part.
  \item Lea un número de parte y un nombre de parte del teclado en los miembros individuales de la variable a.
  \item Asigne los valores de miembro de la variable a al elemento 3 de la matriz b.
  \item Asigne la dirección de la matriz b a la variable de puntero ptr.
  \item Imprima los valores de miembros del elemento 3 de la matriz b usando la variable ptr y el operador de puntero de estructura para referirse a los miembros.
\end{enumerate}
\subsubsection{Ejercicio}
Dada la estructura  \texttt{personaje\_t}, realizar un programa que solicite al usuario ingresar los datos necesarios para completar la estructura.
Los miembros \texttt{escudo} y \texttt{sales} deben ser inicializados en 0. 
El miembro \texttt{vida} en $150.0$.
El miembro \texttt{rango} se debe generar en forma aleatoria, con un valor entre $0$ y $100$.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/personaje.c}
El programa debe cargar los miembros mediante dos formas: la primera en forma directa con la variable \texttt{personaje}, y en forma indirecta mediante el puntero \texttt{pPersonaje} según la siguiente definición:

\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/sol_personaje_ej.c}
Acontinuación se adjunta un ejemplo de salida válido:
\lstset{inputencoding=utf8/latin1}
{\small
\lstinputlisting[backgroundcolor = \color{lightgray}]{code/sol_personaje_salida.mn}
}

%--------------------------------------------------------------------------------
%--------------------------------------------------------------------------------
\subsection*{Campos de bits}
\subsubsection{Ejercicio}
Dado el siguiente programa, implementar las funciones según las especificaciones indicadas en los comentarios.
El mazo de cartas debe ser inicializado de manera aleatoria, estando permitida la repetición de cartas.
\lstset{inputencoding=utf8/latin1}
\lstinputlisting[style=customc]{code/ejercicio1_campo.c}
A continuación se muestra un ejemplo de salida del programa:
\lstset{inputencoding=utf8/latin1}
{\small
\lstinputlisting[backgroundcolor = \color{lightgray}]{code/ejercicio1_campo_completo_salida.mn}
}

\subsection*{Manejo de archivos en C.}

\subsection{Preguntas:}
\begin{itemize}[a)]
  \item Completar los espacios en blanco:\\
    \begin{enumerate}
      \item La función \underspace cierra un archivo.
      \item La función \underspace lee los datos de un archivo de manera similar a cómo scanf lee desde stdin.
      \item La función \underspace lee un caracter de un archivo especificado.
      \item La función \underspace reposiciona el puntero de posición del archivo a una ubicación específica en el archivo.
    \end{enumerate}
\end{itemize}
\subsubsection{Ejercicio}
Indique cuáles de los siguientes son verdaderos y cuáles son falsos.\\
Si es falso, explique por qué.
\begin{itemize}[a)]
  \item La función fscanf no se puede usar para leer datos de la entrada estándar.
  \item Debe usar explícitamente fopen para abrir la entrada estándar, la salida estándar y las secuencias de error estándar.
  \item Un programa debe llamar explícitamente a la función fclose para cerrar un archivo.
  \item Si el puntero de posición del archivo apunta a una ubicación en un archivo secuencial que no sea el comienzo del archivo, el archivo debe cerrarse y volverse a abrir para leerlo desde el principio del archivo.
  \item La función fprintf puede escribir en la salida estándar.
  \item Los datos en archivos de acceso secuencial siempre se actualizan sin sobrescribir otros datos.
  \item No es necesario buscar a través de todos los registros en un archivo de acceso aleatorio para encontrar un registro específico.
  \item Los registros en archivos de acceso aleatorio no tienen una longitud uniforme.
  \item La función fseek puede buscar solo en relación con el comienzo de un archivo.
\end{itemize}

\subsubsection{Ejercicio}
Encuentre el error en cada uno de los siguientes segmentos del programa y explique cómo corregirlo.
\begin{enumerate}[a)]
  \item El archivo al que hace referencia fPtr ("pagos.dat") no se ha abierto.
    \lstset{inputencoding=utf8/latin1}
    \lstinputlisting[style=customc]{code/ejercicio2a.c}
  \item \ \ \ 
    \lstinputlisting[style=customc]{code/ejercicio2b.c}
  \item La siguiente declaración debería leer un registro del archivo "pagos.dat". 
    El puntero de archivo payPtr se refiere a este archivo, y el puntero de archivo recPtr se refiere al archivo "recibir.dat"
    \lstinputlisting[style=customc]{code/ejercicio2c.c}
  \item El archivo "tools.dat" debe abrirse para agregar datos al archivo sin descartar los datos actuales.
    \lstinputlisting[style=customc]{code/ejercicio2d.c}
  \item El archivo "course.dat" debe abrirse para agregarlo sin modificar el contenido actual del archivo.
    \lstinputlisting[style=customc]{code/ejercicio2e.c}
\end{enumerate}



